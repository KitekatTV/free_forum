# Веб-приложение с заранее заложенными уязвимостями

## Инструкция для сборке и запуску

Необходимые компоненты:
* Erlang/OTP 25+ 
* Elixir 1.14+ 
* PostgreSQL (тестировано на 17.4) 

```sh
mix setup
mix phx.server
```

## Почему готовый фреймворк и почему Phoenix?

В наше время разработчик вряд ли будет писать своё веб-приложение с нуля
и отдаст предпочтение какому-либо готовому фреймворку ведь их использование готовых
фреймворков несёт за собой множество преимуществ. В первую очередь - простота разработки,
написание сервера с нуля может занять крайне много времени и крайне нецелесообразно,
ведь структура всех веб-приложений, по сути, одинаковая. Но более того, большинство
фреймворков даёт какую-либо защиту уязвимостей по умолчанию.

Зачем использовать готовый фреймворк с защитой от уязвимостей для демонстрации уязвимостей?
Писать плохой и уязвимый код - просто, поэтому эти же фреймворки зачастую включают в себя
"защиту от дурака" - они проектируются так, чтобы случайно создать уязвимость было как
можно сложнее. Помимо этого, создание подобного приложения на готовом фреймворке позволяет
приблизить демонстрационные уязвимости к тем, что встречаются в настоящих приложениях.

Для создания этого приложения был выбран фреймворк Phoenix. Причин выбрать его много,
но из тех которые относятся к этому приложению, стоит отметить:

* Встроенный шаблон механизма аутентификации. Он дает множество гарантий безопасности,
включая ту что интересует нас больше всего - защиту от CSRF-атак.

* Встроенная защита от XSS, валидирующая ввод пользователя во многих местах по
умолчанию.

## Структура приложения

* `/assets` - Исходники для фронт-энда. JS и CSS для основной настройки фронт-энда придожения, а также Tailwind
* `/config` - Файлы конфигурации фреймфорка, базы данных, логирования и так далее
* `/priv` - Необходимые ресурсы, не являющиеся кодом, например изображения, шрифты и файлы перевода. Также тут
находится каталог /static/media, в который сохраняются файлы, загруженные пользователем
* `/lib` - Исходный код приложения
  - `/free_forum` - Бизнес-логика и взаимодействие с ДБ
    - `/accounts` - Модель пользователя, а также реализация отправки писем для подтверждения эл. почты и реализация самого подтверждения
    - `/user_content` - Модели для постов и комментариев
    - Методы для взаимодействия с ДБ
  - `/free_forum_web` - Код отвечающий за веб-составляющую
    - `/components` - Содержит шаблоны некоторых элементов, а также основу страницы, для избежания повторного написания разметки
    - `/controllers` - Реализация всех эндпоинтов, а также файлы разметки в формате HEEx
    - `/live` - Содержит разметку для страниц LiveView (Изменение содержания страницы происходит путём отправки патчей на клиент,
      а не обновления страницы целиком). Такой формат используется для страницы со списком тем (для реализации поиска и сортировки тем),
      а также для страниц самих тем (для динамического отображения окна для оставления комментария)

## Роутинг

* `/` - Лендинг (Домашняя страница)
* `/dev/...` - Панель разработчика Phoenix, в данной демонстрации не применяется
* `/users/register` - GET/POST - Страница и эндпоинт для регистрации нового аккаунта
* `/users/log_in` - GET/POST - Страница и эндпоинт для входа в аккаунт
* `/users/log_out` - DELETE - Эндпоинт для выхода из аккаунта
* `/users/reset_password` - GET/POST Страница и эндпоинт для запроса сброса пароля
* `/users/reset_password/:token` - GET/PUT Страница и эндпоинт для подтверждения сброса пароля
* `/users/settings` - GET/PUT Страница и эндпоинт для настроек пользователя (смена пароля и/или эл. почты)
* `/users/settings/confirm_email/:token`, `/users/confirm` и `/users/confirm/:token` - Подтверждение адреса. эл почты.
Так как это неполноценное приложение, у него не настроена автоматическая отправка почты, поэтому данный функционал
не используется. Тем не менее, он все еще работоспособен, письма, которые должны быть отправлены пользователям, можно найти
в панели разработчика по адресу `/dev/mailbox`
* `/topics`
  - GET - Страница, отображающая все посты
  - POST - Эндпоинт для создания нового поста
* `/topics/new` - Страница для создания нового поста с обсуждением
* `/topics/:id`
  - GET - Страница определенного поста 
  - PUT/PATCH - Эндпоинт для изменения поста
  - DELETE - Эндпоинт для удаления поста
* `/topics/:id/edit` - Страница редактирования поста
* `/topics/:id/comment/...` - Функционал для удаления/изменения комментариев. Не был реализован до конца, в основном
из-за ненадобности

## Заложенные уязвимости

*Основные реализации уязвимостей в коде можно найти с помощью поиска "HACK:" по коду*

### XSS
XSS уязвимость была реализована самым примитивным образом:
[содержимое постов отображается](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/live/topic.ex#L42)
с помощью функции [raw()](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html#raw/1). Она помечает содержимое как "сырое", отключая любую
фильтрацию HTML-тегов. На самом деле, сама проблема тут состоит не столько в том, что отображаются теги, а в том, что содержимое никак
не фильтруется при создании поста, подвергая приложение Stored XSS. Способов устранить её может быть несколько, а именно:

* Убрать вызов функции raw целиком, таким образом гарантированно закрывая уязвимость. Однако в такой ситуации пострадает функционал приложения

* [В момент создания нового поста](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/controllers/topic_controller.ex#L12) удалять тег
`<script>` или выдавать ошибку при попытке включить его в содержимое. Хотя с первого взгляда это может показаться хорошим решением, на
практике оно наивно и неверно, так как XSS не ограничивается этим тегом, да и пытаться запретить все методы встроить скрипт черным списком будут
крайне затруднительно

* Изменить способ задания разметки пользователем. Самым эффективным способом будет применить [HTML-фильтрацию](https://hexdocs.pm/phoenix_html/Phoenix.HTML.html#html_escape/1),
а разметку реализовать другим способом. Хорошей идеей будет использовать Markdown, такая разметка не будет уступать в функционале, а реализовать её можно, например,
функцией [as_html() библиотеки Earmark](https://hexdocs.pm/earmark/Earmark.html#as_html/2). Образец такого безопасного кода с разметкой будет выглядеть примерно так:

```elixir
content = topic_params["content"]
|> html_escape
|> Earmark.as_html

Map.put(topic_params, "content", content)
```

### IDOR
В основном в IDOR можно выделить два основных момента: возможность найти объекты, не зная точного адреса и отсутствие проверки разрешения на доступ к объекту.

В первом случае проблемой чаще всего является то, каким образом объект адресуется в URL. В нашем случае - это посты, которые можно найти по адресу
/topics/:id, где :id - сам идентификатор поста. Для того чтобы обнаружить проблему, сначала посмотрим на
[код роутера](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/router.ex#L57),
где можно заметить, что часть URL, которая отвечает за идентификатор, передается далее в параметры с идентификатором `topic`. Далее, просмотрев
[исходный код контроллера](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/live/topic.ex#L138) увидим, что в большинстве случаев идентификатор -
это использование PRIMARY_ID структуры, который является автоувеличивающимся числом. Таким образом, мы можем найти нужный нам пост, просто перебирая числа.

Это приводит нас ко второй проблеме: зная, как найти любой пост, злоумышленнику будет проще эксплуатировать отсутствие проверок разрешения. В нашем приложении
существует две таких уязвимости. Первая это доступ к ВИП-постам; на данный момент наличие ВИП-статуса у пользователя проверяется на странице списка постов,
[просто не отправляя пользователя информацию о ВИП-постах](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/live/topics.ex#L119). При этом при
заходе на сам пост (а также попытке его изменения через POST), проверок не выполняется. Закрывается эта уязвимость, разумеется, добавлением проверки, например:

```elixir
case conn.assigns do
  %{current_user: %{vip: true}} -> conn

  _ ->
    conn
    |> put_flash(:error, "Только ВИП-пользователи могут просматривать данное обсуждение")
    |> redirect(to: ~p"/topics")
    |> halt()
end
```

Помимо этого, присутствует и вторая уязвимость:
[отсутствует проверка на авторство при попытке редактирования поста](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/controllers/topic_controller.ex#L69).
Таким образом зная адрес поста, злоумышленник может добавить `/new` к URL, чтобы отредактировать его. В данном случае проверка,
закрывающая уязвимость может выглядеть примерно так:

```elixir
if topic.author_id != conn.assigns[:current_user].id do
  conn
  |> put_flash(:error, "У вас нет разрешения на редактирование данного поста")
  |> redirect(to: ~p"/topics")
else
  ...
end
```

### Unrestricted File Upload
В контексте нашего приложения эта уязвимость не так серьёзна, так как мы никак не обрабатываем файлы, которые загружают пользователи
[(за исключением проверки Content-Type для отределения разметки для отображения вложения)](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/controllers/topic_controller.ex#L23).
Таким образом в нашем приложении загрузка файлов несет с собой лишь две угрозы:

* Отказ в обслуживании путем переполнения памяти на сервере. Данная проблема решается ограничением максимального размера файла
(которое присутствует по умолчанию)
и ограничением количества/суммарного размера загружаемых пользователем файлов

* Потенциально вредоносные файлы. Такие файлы могут представлять опасность, как и для пользователей, которые могут их скачать
с нашего приложения, так и для нашего сервера, если злоумышленник найдёт способ его исполнить. Эту уязвимость можно закрыть
любыми антивирусными проверками, как и установленными на сервер, так и, например, с помощью
[API VirusTotal](https://docs.virustotal.com/reference/overview).

### CSRF
По умолчанию Phoenix предоставляет хорошую защиту от CSRF-атак, поэтому нам придется частично её отключить. Она присутствует в нескольких
местах:

1) [Генерация токена в метаданных заголовка разметки](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/components/layouts/root.html.heex#L6)
2) [Передача токена в параметры сокета с помощью JS](https://github.com/KitekatTV/free_forum/blob/main/assets/js/app.js#L25)
3) [Использование специальной функции в пайплайне](https://github.com/KitekatTV/free_forum/blob/main/lib/free_forum_web/router.ex#L11)

*При отключении защиты целиком, страницы LiveView перестанут работать, поэтому намеренно отключим её лишь для создания нового поста*

Помимо этого, изменим политику SameSite для cookie сессии, таким образом позволив злоумышленнику, например, создать специальную форму,
при отправке которой жертва опубликует пост с содержимым созданным злоумышленником от своего имени.

Так как данная уязвимость является не "случайной ошибкой разработчика", а результатом намеренного отключения защиты, способом её закрытия
будет защиту, а также следить за её соблюдением, в первую очередь при изменении пайплайнов

### SQL
Изначально также было запланировано встроить в приложение уязвимость к SQL-инъекциям, но, ко всеобщему удивлению, библиотека Ecto для
взаимодействия с БД спроектирована так, что это практически (а возможно и целиком) невозможна. Связано это с использованием
библиотекой [неотключаемых prepared statement](https://github.com/elixir-ecto/postgrex/issues/468#issuecomment-506699931),
а также невозможностью поместить два выражения в один запрос (например, разделяя их с помощью `;`)
